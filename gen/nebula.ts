/* eslint-disable */
// @generated by protobuf-ts 2.9.1 with parameter client_grpc1,long_type_number,ts_nocheck,eslint_disable
// @generated from protobuf file "nebula.proto" (package "nebula.service", syntax proto3)
// tslint:disable
// @ts-nocheck
//
//
// Copyright 2017-present varchar.io
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * The request message containing the user's name.
 *
 * @generated from protobuf message nebula.service.EchoRequest
 */
export interface EchoRequest {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
}
/**
 * The response message containing the greetings
 *
 * @generated from protobuf message nebula.service.EchoResponse
 */
export interface EchoResponse {
    /**
     * @generated from protobuf field: string message = 1;
     */
    message: string;
}
/**
 * Url shorten service
 *
 * @generated from protobuf message nebula.service.UrlData
 */
export interface UrlData {
    /**
     * @generated from protobuf field: string code = 1;
     */
    code: string;
    /**
     * @generated from protobuf field: string raw = 2;
     */
    raw: string;
}
/**
 * @generated from protobuf message nebula.service.TableStateRequest
 */
export interface TableStateRequest {
    /**
     * @generated from protobuf field: string table = 1;
     */
    table: string;
}
/**
 * @generated from protobuf message nebula.service.ListTables
 */
export interface ListTables {
    /**
     * @generated from protobuf field: uint32 limit = 1;
     */
    limit: number;
}
/**
 * @generated from protobuf message nebula.service.TableList
 */
export interface TableList {
    /**
     * @generated from protobuf field: repeated string table = 1;
     */
    table: string[];
}
/**
 * @generated from protobuf message nebula.service.TableStateResponse
 */
export interface TableStateResponse {
    /**
     * @generated from protobuf field: int32 blockCount = 1;
     */
    blockCount: number;
    /**
     * @generated from protobuf field: int64 rowCount = 2;
     */
    rowCount: number;
    /**
     * @generated from protobuf field: int64 memSize = 3;
     */
    memSize: number;
    /**
     * @generated from protobuf field: int64 minTime = 4;
     */
    minTime: number;
    /**
     * @generated from protobuf field: int64 maxTime = 5;
     */
    maxTime: number;
    /**
     * columns = dimension columns + metric columns
     * metric column are column with number types, others are dimension columns
     *
     * @generated from protobuf field: repeated string dimension = 6;
     */
    dimension: string[];
    /**
     * @generated from protobuf field: repeated string metric = 7;
     */
    metric: string[];
    /**
     * column histograms serialized in JSON string
     *
     * @generated from protobuf field: repeated string hists = 8;
     */
    hists: string[];
}
/**
 * TODO(cao): reference Constraints.js for GROUP/RULE generation to build
 * predicates tree Current definition only supports one group basically. (nested
 * groups) NOTE - based on the code generation rule, we don't put plural term
 * for repeated field so the method will like add_value rather than add_values
 * Based on column type - the value will be converted from string always
 * Adding n_value for integers and d_value for floating values if client uses
 * it. Adding values as customized data list serialzied in some format (data
 * type same as column type)
 *
 * @generated from protobuf message nebula.service.Predicate
 */
export interface Predicate {
    /**
     * @generated from protobuf field: string column = 1;
     */
    column: string;
    /**
     * @generated from protobuf field: nebula.service.Operation op = 2;
     */
    op: Operation;
    /**
     * @generated from protobuf field: repeated string value = 3;
     */
    value: string[];
    /**
     * @generated from protobuf field: repeated int64 n_value = 4 [jstype = JS_STRING];
     */
    nValue: string[];
    /**
     * @generated from protobuf field: repeated double d_value = 5;
     */
    dValue: number[];
    /**
     * allow client to pass a zipped values representing
     * an list of values in current column type.
     * zip format and zip count show what algo used to zip the original array.
     * zip count indicates how many values zipped inside.
     *
     * @generated from protobuf field: bytes zip = 6;
     */
    zip: Uint8Array;
    /**
     * @generated from protobuf field: nebula.service.ZipFormat ZipFormat = 7 [json_name = "ZipFormat"];
     */
    zipFormat: ZipFormat;
    /**
     * @generated from protobuf field: int32 zipCount = 8;
     */
    zipCount: number;
}
/**
 * define filter - a filter is formed by a list of predicates combined by AND or
 * OR
 *
 * @generated from protobuf message nebula.service.PredicateAnd
 */
export interface PredicateAnd {
    /**
     * @generated from protobuf field: repeated nebula.service.Predicate expression = 1;
     */
    expression: Predicate[];
}
/**
 * @generated from protobuf message nebula.service.PredicateOr
 */
export interface PredicateOr {
    /**
     * @generated from protobuf field: repeated nebula.service.Predicate expression = 1;
     */
    expression: Predicate[];
}
/**
 * A metric is defined by rollup method on a column
 *
 * @generated from protobuf message nebula.service.Metric
 */
export interface Metric {
    /**
     * @generated from protobuf field: string column = 1;
     */
    column: string;
    /**
     * @generated from protobuf field: nebula.service.Rollup method = 2;
     */
    method: Rollup;
}
/**
 * @generated from protobuf message nebula.service.Order
 */
export interface Order {
    /**
     * @generated from protobuf field: string column = 1;
     */
    column: string;
    /**
     * @generated from protobuf field: nebula.service.OrderType type = 2;
     */
    type: OrderType;
}
/**
 * define custom column described by a script
 *
 * @generated from protobuf message nebula.service.CustomColumn
 */
export interface CustomColumn {
    /**
     * @generated from protobuf field: string column = 1;
     */
    column: string;
    /**
     * @generated from protobuf field: nebula.service.CustomType type = 2;
     */
    type: CustomType;
    /**
     * @generated from protobuf field: string expr = 3;
     */
    expr: string;
}
/**
 * define query request
 *
 * @generated from protobuf message nebula.service.QueryRequest
 */
export interface QueryRequest {
    /**
     * @generated from protobuf field: string table = 1;
     */
    table: string;
    /**
     * at the top tree as filter - it can be only one, either AND or OR
     *
     * @generated from protobuf field: optional nebula.service.PredicateAnd filterA = 2;
     */
    filterA?: PredicateAnd;
    /**
     * @generated from protobuf field: optional nebula.service.PredicateOr filterO = 3;
     */
    filterO?: PredicateOr;
    /**
     * every query will specify time range for the data to query - this is
     * enforced start time and end time are unix timestamp with GMT timezone - no
     * delta time range filter will be inclusive on both ends as [start, end]
     *
     * @generated from protobuf field: int64 start = 4;
     */
    start: number;
    /**
     * @generated from protobuf field: int64 end = 5;
     */
    end: number;
    /**
     * window size is used in time serials query that aggregate timestamp into a
     * window as bucket this is in seconds (if the value is 60 -> one minute)
     *
     * @generated from protobuf field: uint32 window = 6;
     */
    window: number;
    /**
     * dimensions (key columns / group by columns) to pull metrics for
     *
     * @generated from protobuf field: repeated string dimension = 7;
     */
    dimension: string[];
    /**
     * metric list, such as sum(col_a), count(col_b)
     *
     * @generated from protobuf field: repeated nebula.service.Metric metric = 8;
     */
    metric: Metric[];
    /**
     * usually query only takes top X results based on order spec
     *
     * @generated from protobuf field: uint32 top = 9;
     */
    top: number;
    /**
     * define order spec
     *
     * @generated from protobuf field: nebula.service.Order order = 10;
     */
    order?: Order;
    /**
     * display type for query result
     *
     * @generated from protobuf field: bool timeline = 11;
     */
    timeline: boolean;
    /**
     * custom column list
     *
     * @generated from protobuf field: repeated nebula.service.CustomColumn custom = 12;
     */
    custom: CustomColumn[];
    /**
     * custom time unit
     *
     * @generated from protobuf field: uint64 time_unit = 13;
     */
    timeUnit: number;
    /**
     * timezone offset in minutes (following javascript getTimezoneOffset
     * convention) timezone behind GMT is positive, ahead is negative (how to
     * bring it back to GMT)
     *
     * @generated from protobuf field: int64 tz_offset = 14;
     */
    tzOffset: number;
}
/**
 * define query processing metrics
 *
 * @generated from protobuf message nebula.service.Statistics
 */
export interface Statistics {
    /**
     * end to end query time in milliseconds
     *
     * @generated from protobuf field: uint32 queryTimeMs = 1;
     */
    queryTimeMs: number;
    /**
     * total rows scanned for the query
     *
     * @generated from protobuf field: uint64 rowsScanned = 2;
     */
    rowsScanned: number;
    /**
     * total blocks scanned for the query
     *
     * @generated from protobuf field: uint64 blocksScanned = 3;
     */
    blocksScanned: number;
    /**
     * total number of rows in result (before limit)
     *
     * @generated from protobuf field: uint64 rowsReturn = 4;
     */
    rowsReturn: number;
    /**
     * query result - 0=success, other error code to look up
     *
     * @generated from protobuf field: uint32 error = 5;
     */
    error: number;
    /**
     * may place error message here if failed
     *
     * @generated from protobuf field: string message = 6;
     */
    message: string;
}
/**
 * define query response from server
 *
 * @generated from protobuf message nebula.service.QueryResponse
 */
export interface QueryResponse {
    /**
     * @generated from protobuf field: nebula.service.Statistics stats = 1;
     */
    stats?: Statistics;
    /**
     * @generated from protobuf field: nebula.service.DataType type = 2;
     */
    type: DataType;
    /**
     * @generated from protobuf field: bytes data = 3;
     */
    data: Uint8Array;
}
/**
 * on-demand data loading request
 *
 * @generated from protobuf message nebula.service.LoadRequest
 */
export interface LoadRequest {
    /**
     * load type
     *
     * @generated from protobuf field: nebula.service.LoadType type = 1;
     */
    type: LoadType;
    /**
     * template table name
     *
     * @generated from protobuf field: string table = 2;
     */
    table: string;
    /**
     * different type will utilize this json object for different purpose.
     * configured template uses it as parameters instantiate a template.
     * google sheets will use it store google sheet spec
     *
     * @generated from protobuf field: string json = 3;
     */
    json: string;
    /**
     * TTL in seconds for the data to live
     *
     * @generated from protobuf field: uint32 ttl = 4;
     */
    ttl: number;
}
/**
 * load command response
 *
 * @generated from protobuf message nebula.service.LoadResponse
 */
export interface LoadResponse {
    /**
     * load state: error=0 indicating successâˆ
     *
     * @generated from protobuf field: nebula.service.LoadError error = 1;
     */
    error: LoadError;
    /**
     * loading time in milliseconds
     *
     * @generated from protobuf field: uint32 loadTimeMs = 2;
     */
    loadTimeMs: number;
    /**
     * loaded instance table name
     *
     * @generated from protobuf field: string table = 3;
     */
    table: string;
    /**
     * extra message the server wants to share
     *
     * @generated from protobuf field: string message = 4;
     */
    message: string;
}
/**
 * @generated from protobuf message nebula.service.ServiceInfo
 */
export interface ServiceInfo {
    /**
     * IP address
     *
     * @generated from protobuf field: string ipv4 = 1;
     */
    ipv4: string;
    /**
     * service port
     *
     * @generated from protobuf field: uint32 port = 2;
     */
    port: number;
    /**
     * host name (optional)
     *
     * @generated from protobuf field: string host = 3;
     */
    host: string;
    /**
     * service role/tier - server, node, web, etc.
     *
     * @generated from protobuf field: nebula.service.ServiceTier tier = 4;
     */
    tier: ServiceTier;
}
/**
 * @generated from protobuf message nebula.service.PingResponse
 */
export interface PingResponse {
}
/**
 * single predicate which is column op [list of values]
 * Operation defines comparions op to form a predicate: =, !=, >, <
 *
 * @generated from protobuf enum nebula.service.Operation
 */
export enum Operation {
    /**
     * @generated from protobuf enum value: EQ = 0;
     */
    EQ = 0,
    /**
     * @generated from protobuf enum value: NEQ = 1;
     */
    NEQ = 1,
    /**
     * @generated from protobuf enum value: MORE = 2;
     */
    MORE = 2,
    /**
     * @generated from protobuf enum value: LESS = 3;
     */
    LESS = 3,
    /**
     * @generated from protobuf enum value: LIKE = 4;
     */
    LIKE = 4,
    /**
     * @generated from protobuf enum value: ILIKE = 5;
     */
    ILIKE = 5,
    /**
     * @generated from protobuf enum value: UNLIKE = 6;
     */
    UNLIKE = 6,
    /**
     * @generated from protobuf enum value: IUNLIKE = 7;
     */
    IUNLIKE = 7
}
/**
 * @generated from protobuf enum nebula.service.ZipFormat
 */
export enum ZipFormat {
    /**
     * @generated from protobuf enum value: DELTA = 0;
     */
    DELTA = 0
}
/**
 * This defines all the aggregate metric methods suppored in nebula
 *
 *
 * @generated from protobuf enum nebula.service.Rollup
 */
export enum Rollup {
    /**
     * @generated from protobuf enum value: COUNT = 0;
     */
    COUNT = 0,
    /**
     * @generated from protobuf enum value: SUM = 1;
     */
    SUM = 1,
    /**
     * @generated from protobuf enum value: MIN = 2;
     */
    MIN = 2,
    /**
     * @generated from protobuf enum value: MAX = 3;
     */
    MAX = 3,
    /**
     * @generated from protobuf enum value: AVG = 4;
     */
    AVG = 4,
    /**
     * pre-defined percentile
     *
     * @generated from protobuf enum value: P10 = 5;
     */
    P10 = 5,
    /**
     * @generated from protobuf enum value: P25 = 6;
     */
    P25 = 6,
    /**
     * @generated from protobuf enum value: P50 = 7;
     */
    P50 = 7,
    /**
     * @generated from protobuf enum value: P75 = 8;
     */
    P75 = 8,
    /**
     * @generated from protobuf enum value: P90 = 9;
     */
    P90 = 9,
    /**
     * @generated from protobuf enum value: P99 = 10;
     */
    P99 = 10,
    /**
     * @generated from protobuf enum value: P99_9 = 11;
     */
    P99_9 = 11,
    /**
     * @generated from protobuf enum value: P99_99 = 12;
     */
    P99_99 = 12,
    /**
     * call stack merge
     *
     * @generated from protobuf enum value: TREEMERGE = 13;
     */
    TREEMERGE = 13,
    /**
     * estimated cardinality
     *
     * @generated from protobuf enum value: CARD_EST = 14;
     */
    CARD_EST = 14,
    /**
     * @generated from protobuf enum value: HIST = 15;
     */
    HIST = 15
}
/**
 * define ordering spec - limiting to order by single column in returning result
 *
 * @generated from protobuf enum nebula.service.OrderType
 */
export enum OrderType {
    /**
     * @generated from protobuf enum value: ASC = 0;
     */
    ASC = 0,
    /**
     * @generated from protobuf enum value: DESC = 1;
     */
    DESC = 1,
    /**
     * @generated from protobuf enum value: NONE = 2;
     */
    NONE = 2
}
/**
 * define supported custom column type which is a sub set of nebula types
 *
 * @generated from protobuf enum nebula.service.CustomType
 */
export enum CustomType {
    /**
     * @generated from protobuf enum value: INT = 0;
     */
    INT = 0,
    /**
     * @generated from protobuf enum value: LONG = 1;
     */
    LONG = 1,
    /**
     * @generated from protobuf enum value: FLOAT = 2;
     */
    FLOAT = 2,
    /**
     * @generated from protobuf enum value: DOUBLE = 3;
     */
    DOUBLE = 3,
    /**
     * @generated from protobuf enum value: STRING = 4;
     */
    STRING = 4
}
/**
 * @generated from protobuf enum nebula.service.DataType
 */
export enum DataType {
    /**
     * use native flat buffer format
     * it has its own serialziation and deserialization logic
     *
     * @generated from protobuf enum value: NATIVE = 0;
     */
    NATIVE = 0,
    /**
     * JSON string sending in bytes buffer
     *
     * @generated from protobuf enum value: JSON = 1;
     */
    JSON = 1
}
/**
 * @generated from protobuf enum nebula.service.LoadType
 */
export enum LoadType {
    /**
     * load command to load data preconfigured (cluster.yml)
     *
     * @generated from protobuf enum value: CONFIG = 0;
     */
    CONFIG = 0,
    /**
     * A spec to load google sheet
     *
     * @generated from protobuf enum value: GOOGLE_SHEET = 1;
     */
    GOOGLE_SHEET = 1,
    /**
     * A spec to load a data file(s) by auto detecting its schema
     *
     * @generated from protobuf enum value: DEMAND = 2;
     */
    DEMAND = 2,
    /**
     * A simple command to unload a table
     *
     * @generated from protobuf enum value: UNLOAD = 3;
     */
    UNLOAD = 3
}
/**
 * load error
 *
 * @generated from protobuf enum nebula.service.LoadError
 */
export enum LoadError {
    /**
     * @generated from protobuf enum value: SUCCESS = 0;
     */
    SUCCESS = 0,
    /**
     * @generated from protobuf enum value: TEMPLATE_NOT_FOUND = 1;
     */
    TEMPLATE_NOT_FOUND = 1,
    /**
     * @generated from protobuf enum value: MISSING_PARAM = 2;
     */
    MISSING_PARAM = 2,
    /**
     * @generated from protobuf enum value: MISSING_BUCKET_VALUE = 3;
     */
    MISSING_BUCKET_VALUE = 3,
    /**
     * @generated from protobuf enum value: UNAUTHORIZED = 4;
     */
    UNAUTHORIZED = 4,
    /**
     * @generated from protobuf enum value: EMPTY_RESULT = 5;
     */
    EMPTY_RESULT = 5,
    /**
     * @generated from protobuf enum value: NOT_SUPPORTED = 6;
     */
    NOT_SUPPORTED = 6,
    /**
     * @generated from protobuf enum value: IN_LOADING = 7;
     */
    IN_LOADING = 7,
    /**
     * @generated from protobuf enum value: PARSE_ERROR = 8;
     */
    PARSE_ERROR = 8,
    /**
     * @generated from protobuf enum value: BAD_SCHEMA = 9;
     */
    BAD_SCHEMA = 9
}
/**
 * @generated from protobuf enum nebula.service.ServiceTier
 */
export enum ServiceTier {
    /**
     * @generated from protobuf enum value: WEB = 0;
     */
    WEB = 0,
    /**
     * @generated from protobuf enum value: SERVER = 1;
     */
    SERVER = 1,
    /**
     * @generated from protobuf enum value: NODE = 2;
     */
    NODE = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class EchoRequest$Type extends MessageType<EchoRequest> {
    constructor() {
        super("nebula.service.EchoRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EchoRequest>): EchoRequest {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EchoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EchoRequest): EchoRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EchoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message nebula.service.EchoRequest
 */
export const EchoRequest = new EchoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EchoResponse$Type extends MessageType<EchoResponse> {
    constructor() {
        super("nebula.service.EchoResponse", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EchoResponse>): EchoResponse {
        const message = { message: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EchoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EchoResponse): EchoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EchoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message nebula.service.EchoResponse
 */
export const EchoResponse = new EchoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UrlData$Type extends MessageType<UrlData> {
    constructor() {
        super("nebula.service.UrlData", [
            { no: 1, name: "code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "raw", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UrlData>): UrlData {
        const message = { code: "", raw: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UrlData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UrlData): UrlData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string code */ 1:
                    message.code = reader.string();
                    break;
                case /* string raw */ 2:
                    message.raw = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UrlData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string code = 1; */
        if (message.code !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.code);
        /* string raw = 2; */
        if (message.raw !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.raw);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message nebula.service.UrlData
 */
export const UrlData = new UrlData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TableStateRequest$Type extends MessageType<TableStateRequest> {
    constructor() {
        super("nebula.service.TableStateRequest", [
            { no: 1, name: "table", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TableStateRequest>): TableStateRequest {
        const message = { table: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TableStateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TableStateRequest): TableStateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string table */ 1:
                    message.table = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TableStateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string table = 1; */
        if (message.table !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.table);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message nebula.service.TableStateRequest
 */
export const TableStateRequest = new TableStateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListTables$Type extends MessageType<ListTables> {
    constructor() {
        super("nebula.service.ListTables", [
            { no: 1, name: "limit", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ListTables>): ListTables {
        const message = { limit: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListTables>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListTables): ListTables {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 limit */ 1:
                    message.limit = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListTables, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 limit = 1; */
        if (message.limit !== 0)
            writer.tag(1, WireType.Varint).uint32(message.limit);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message nebula.service.ListTables
 */
export const ListTables = new ListTables$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TableList$Type extends MessageType<TableList> {
    constructor() {
        super("nebula.service.TableList", [
            { no: 1, name: "table", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TableList>): TableList {
        const message = { table: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TableList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TableList): TableList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string table */ 1:
                    message.table.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TableList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string table = 1; */
        for (let i = 0; i < message.table.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.table[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message nebula.service.TableList
 */
export const TableList = new TableList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TableStateResponse$Type extends MessageType<TableStateResponse> {
    constructor() {
        super("nebula.service.TableStateResponse", [
            { no: 1, name: "blockCount", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "rowCount", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 3, name: "memSize", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 4, name: "minTime", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 5, name: "maxTime", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 6, name: "dimension", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "metric", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "hists", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TableStateResponse>): TableStateResponse {
        const message = { blockCount: 0, rowCount: 0, memSize: 0, minTime: 0, maxTime: 0, dimension: [], metric: [], hists: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TableStateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TableStateResponse): TableStateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 blockCount */ 1:
                    message.blockCount = reader.int32();
                    break;
                case /* int64 rowCount */ 2:
                    message.rowCount = reader.int64().toNumber();
                    break;
                case /* int64 memSize */ 3:
                    message.memSize = reader.int64().toNumber();
                    break;
                case /* int64 minTime */ 4:
                    message.minTime = reader.int64().toNumber();
                    break;
                case /* int64 maxTime */ 5:
                    message.maxTime = reader.int64().toNumber();
                    break;
                case /* repeated string dimension */ 6:
                    message.dimension.push(reader.string());
                    break;
                case /* repeated string metric */ 7:
                    message.metric.push(reader.string());
                    break;
                case /* repeated string hists */ 8:
                    message.hists.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TableStateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 blockCount = 1; */
        if (message.blockCount !== 0)
            writer.tag(1, WireType.Varint).int32(message.blockCount);
        /* int64 rowCount = 2; */
        if (message.rowCount !== 0)
            writer.tag(2, WireType.Varint).int64(message.rowCount);
        /* int64 memSize = 3; */
        if (message.memSize !== 0)
            writer.tag(3, WireType.Varint).int64(message.memSize);
        /* int64 minTime = 4; */
        if (message.minTime !== 0)
            writer.tag(4, WireType.Varint).int64(message.minTime);
        /* int64 maxTime = 5; */
        if (message.maxTime !== 0)
            writer.tag(5, WireType.Varint).int64(message.maxTime);
        /* repeated string dimension = 6; */
        for (let i = 0; i < message.dimension.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.dimension[i]);
        /* repeated string metric = 7; */
        for (let i = 0; i < message.metric.length; i++)
            writer.tag(7, WireType.LengthDelimited).string(message.metric[i]);
        /* repeated string hists = 8; */
        for (let i = 0; i < message.hists.length; i++)
            writer.tag(8, WireType.LengthDelimited).string(message.hists[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message nebula.service.TableStateResponse
 */
export const TableStateResponse = new TableStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Predicate$Type extends MessageType<Predicate> {
    constructor() {
        super("nebula.service.Predicate", [
            { no: 1, name: "column", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "op", kind: "enum", T: () => ["nebula.service.Operation", Operation] },
            { no: 3, name: "value", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "n_value", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 3 /*ScalarType.INT64*/ },
            { no: 5, name: "d_value", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "zip", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 7, name: "ZipFormat", kind: "enum", jsonName: "ZipFormat", T: () => ["nebula.service.ZipFormat", ZipFormat] },
            { no: 8, name: "zipCount", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Predicate>): Predicate {
        const message = { column: "", op: 0, value: [], nValue: [], dValue: [], zip: new Uint8Array(0), zipFormat: 0, zipCount: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Predicate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Predicate): Predicate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string column */ 1:
                    message.column = reader.string();
                    break;
                case /* nebula.service.Operation op */ 2:
                    message.op = reader.int32();
                    break;
                case /* repeated string value */ 3:
                    message.value.push(reader.string());
                    break;
                case /* repeated int64 n_value = 4 [jstype = JS_STRING];*/ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.nValue.push(reader.int64().toString());
                    else
                        message.nValue.push(reader.int64().toString());
                    break;
                case /* repeated double d_value */ 5:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.dValue.push(reader.double());
                    else
                        message.dValue.push(reader.double());
                    break;
                case /* bytes zip */ 6:
                    message.zip = reader.bytes();
                    break;
                case /* nebula.service.ZipFormat ZipFormat = 7 [json_name = "ZipFormat"];*/ 7:
                    message.zipFormat = reader.int32();
                    break;
                case /* int32 zipCount */ 8:
                    message.zipCount = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Predicate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string column = 1; */
        if (message.column !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.column);
        /* nebula.service.Operation op = 2; */
        if (message.op !== 0)
            writer.tag(2, WireType.Varint).int32(message.op);
        /* repeated string value = 3; */
        for (let i = 0; i < message.value.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.value[i]);
        /* repeated int64 n_value = 4 [jstype = JS_STRING]; */
        if (message.nValue.length) {
            writer.tag(4, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.nValue.length; i++)
                writer.int64(message.nValue[i]);
            writer.join();
        }
        /* repeated double d_value = 5; */
        if (message.dValue.length) {
            writer.tag(5, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.dValue.length; i++)
                writer.double(message.dValue[i]);
            writer.join();
        }
        /* bytes zip = 6; */
        if (message.zip.length)
            writer.tag(6, WireType.LengthDelimited).bytes(message.zip);
        /* nebula.service.ZipFormat ZipFormat = 7 [json_name = "ZipFormat"]; */
        if (message.zipFormat !== 0)
            writer.tag(7, WireType.Varint).int32(message.zipFormat);
        /* int32 zipCount = 8; */
        if (message.zipCount !== 0)
            writer.tag(8, WireType.Varint).int32(message.zipCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message nebula.service.Predicate
 */
export const Predicate = new Predicate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PredicateAnd$Type extends MessageType<PredicateAnd> {
    constructor() {
        super("nebula.service.PredicateAnd", [
            { no: 1, name: "expression", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Predicate }
        ]);
    }
    create(value?: PartialMessage<PredicateAnd>): PredicateAnd {
        const message = { expression: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PredicateAnd>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PredicateAnd): PredicateAnd {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated nebula.service.Predicate expression */ 1:
                    message.expression.push(Predicate.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PredicateAnd, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated nebula.service.Predicate expression = 1; */
        for (let i = 0; i < message.expression.length; i++)
            Predicate.internalBinaryWrite(message.expression[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message nebula.service.PredicateAnd
 */
export const PredicateAnd = new PredicateAnd$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PredicateOr$Type extends MessageType<PredicateOr> {
    constructor() {
        super("nebula.service.PredicateOr", [
            { no: 1, name: "expression", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Predicate }
        ]);
    }
    create(value?: PartialMessage<PredicateOr>): PredicateOr {
        const message = { expression: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PredicateOr>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PredicateOr): PredicateOr {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated nebula.service.Predicate expression */ 1:
                    message.expression.push(Predicate.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PredicateOr, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated nebula.service.Predicate expression = 1; */
        for (let i = 0; i < message.expression.length; i++)
            Predicate.internalBinaryWrite(message.expression[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message nebula.service.PredicateOr
 */
export const PredicateOr = new PredicateOr$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Metric$Type extends MessageType<Metric> {
    constructor() {
        super("nebula.service.Metric", [
            { no: 1, name: "column", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "method", kind: "enum", T: () => ["nebula.service.Rollup", Rollup] }
        ]);
    }
    create(value?: PartialMessage<Metric>): Metric {
        const message = { column: "", method: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Metric>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Metric): Metric {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string column */ 1:
                    message.column = reader.string();
                    break;
                case /* nebula.service.Rollup method */ 2:
                    message.method = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Metric, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string column = 1; */
        if (message.column !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.column);
        /* nebula.service.Rollup method = 2; */
        if (message.method !== 0)
            writer.tag(2, WireType.Varint).int32(message.method);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message nebula.service.Metric
 */
export const Metric = new Metric$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Order$Type extends MessageType<Order> {
    constructor() {
        super("nebula.service.Order", [
            { no: 1, name: "column", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "enum", T: () => ["nebula.service.OrderType", OrderType] }
        ]);
    }
    create(value?: PartialMessage<Order>): Order {
        const message = { column: "", type: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Order>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Order): Order {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string column */ 1:
                    message.column = reader.string();
                    break;
                case /* nebula.service.OrderType type */ 2:
                    message.type = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Order, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string column = 1; */
        if (message.column !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.column);
        /* nebula.service.OrderType type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).int32(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message nebula.service.Order
 */
export const Order = new Order$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CustomColumn$Type extends MessageType<CustomColumn> {
    constructor() {
        super("nebula.service.CustomColumn", [
            { no: 1, name: "column", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "enum", T: () => ["nebula.service.CustomType", CustomType] },
            { no: 3, name: "expr", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CustomColumn>): CustomColumn {
        const message = { column: "", type: 0, expr: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CustomColumn>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CustomColumn): CustomColumn {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string column */ 1:
                    message.column = reader.string();
                    break;
                case /* nebula.service.CustomType type */ 2:
                    message.type = reader.int32();
                    break;
                case /* string expr */ 3:
                    message.expr = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CustomColumn, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string column = 1; */
        if (message.column !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.column);
        /* nebula.service.CustomType type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).int32(message.type);
        /* string expr = 3; */
        if (message.expr !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.expr);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message nebula.service.CustomColumn
 */
export const CustomColumn = new CustomColumn$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryRequest$Type extends MessageType<QueryRequest> {
    constructor() {
        super("nebula.service.QueryRequest", [
            { no: 1, name: "table", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "filterA", kind: "message", T: () => PredicateAnd },
            { no: 3, name: "filterO", kind: "message", T: () => PredicateOr },
            { no: 4, name: "start", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 5, name: "end", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 6, name: "window", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "dimension", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "metric", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Metric },
            { no: 9, name: "top", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "order", kind: "message", T: () => Order },
            { no: 11, name: "timeline", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "custom", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => CustomColumn },
            { no: 13, name: "time_unit", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 14, name: "tz_offset", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value?: PartialMessage<QueryRequest>): QueryRequest {
        const message = { table: "", start: 0, end: 0, window: 0, dimension: [], metric: [], top: 0, timeline: false, custom: [], timeUnit: 0, tzOffset: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryRequest): QueryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string table */ 1:
                    message.table = reader.string();
                    break;
                case /* optional nebula.service.PredicateAnd filterA */ 2:
                    message.filterA = PredicateAnd.internalBinaryRead(reader, reader.uint32(), options, message.filterA);
                    break;
                case /* optional nebula.service.PredicateOr filterO */ 3:
                    message.filterO = PredicateOr.internalBinaryRead(reader, reader.uint32(), options, message.filterO);
                    break;
                case /* int64 start */ 4:
                    message.start = reader.int64().toNumber();
                    break;
                case /* int64 end */ 5:
                    message.end = reader.int64().toNumber();
                    break;
                case /* uint32 window */ 6:
                    message.window = reader.uint32();
                    break;
                case /* repeated string dimension */ 7:
                    message.dimension.push(reader.string());
                    break;
                case /* repeated nebula.service.Metric metric */ 8:
                    message.metric.push(Metric.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 top */ 9:
                    message.top = reader.uint32();
                    break;
                case /* nebula.service.Order order */ 10:
                    message.order = Order.internalBinaryRead(reader, reader.uint32(), options, message.order);
                    break;
                case /* bool timeline */ 11:
                    message.timeline = reader.bool();
                    break;
                case /* repeated nebula.service.CustomColumn custom */ 12:
                    message.custom.push(CustomColumn.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint64 time_unit */ 13:
                    message.timeUnit = reader.uint64().toNumber();
                    break;
                case /* int64 tz_offset */ 14:
                    message.tzOffset = reader.int64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string table = 1; */
        if (message.table !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.table);
        /* optional nebula.service.PredicateAnd filterA = 2; */
        if (message.filterA)
            PredicateAnd.internalBinaryWrite(message.filterA, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional nebula.service.PredicateOr filterO = 3; */
        if (message.filterO)
            PredicateOr.internalBinaryWrite(message.filterO, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* int64 start = 4; */
        if (message.start !== 0)
            writer.tag(4, WireType.Varint).int64(message.start);
        /* int64 end = 5; */
        if (message.end !== 0)
            writer.tag(5, WireType.Varint).int64(message.end);
        /* uint32 window = 6; */
        if (message.window !== 0)
            writer.tag(6, WireType.Varint).uint32(message.window);
        /* repeated string dimension = 7; */
        for (let i = 0; i < message.dimension.length; i++)
            writer.tag(7, WireType.LengthDelimited).string(message.dimension[i]);
        /* repeated nebula.service.Metric metric = 8; */
        for (let i = 0; i < message.metric.length; i++)
            Metric.internalBinaryWrite(message.metric[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* uint32 top = 9; */
        if (message.top !== 0)
            writer.tag(9, WireType.Varint).uint32(message.top);
        /* nebula.service.Order order = 10; */
        if (message.order)
            Order.internalBinaryWrite(message.order, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* bool timeline = 11; */
        if (message.timeline !== false)
            writer.tag(11, WireType.Varint).bool(message.timeline);
        /* repeated nebula.service.CustomColumn custom = 12; */
        for (let i = 0; i < message.custom.length; i++)
            CustomColumn.internalBinaryWrite(message.custom[i], writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* uint64 time_unit = 13; */
        if (message.timeUnit !== 0)
            writer.tag(13, WireType.Varint).uint64(message.timeUnit);
        /* int64 tz_offset = 14; */
        if (message.tzOffset !== 0)
            writer.tag(14, WireType.Varint).int64(message.tzOffset);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message nebula.service.QueryRequest
 */
export const QueryRequest = new QueryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Statistics$Type extends MessageType<Statistics> {
    constructor() {
        super("nebula.service.Statistics", [
            { no: 1, name: "queryTimeMs", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "rowsScanned", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 3, name: "blocksScanned", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 4, name: "rowsReturn", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 5, name: "error", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Statistics>): Statistics {
        const message = { queryTimeMs: 0, rowsScanned: 0, blocksScanned: 0, rowsReturn: 0, error: 0, message: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Statistics>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Statistics): Statistics {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 queryTimeMs */ 1:
                    message.queryTimeMs = reader.uint32();
                    break;
                case /* uint64 rowsScanned */ 2:
                    message.rowsScanned = reader.uint64().toNumber();
                    break;
                case /* uint64 blocksScanned */ 3:
                    message.blocksScanned = reader.uint64().toNumber();
                    break;
                case /* uint64 rowsReturn */ 4:
                    message.rowsReturn = reader.uint64().toNumber();
                    break;
                case /* uint32 error */ 5:
                    message.error = reader.uint32();
                    break;
                case /* string message */ 6:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Statistics, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 queryTimeMs = 1; */
        if (message.queryTimeMs !== 0)
            writer.tag(1, WireType.Varint).uint32(message.queryTimeMs);
        /* uint64 rowsScanned = 2; */
        if (message.rowsScanned !== 0)
            writer.tag(2, WireType.Varint).uint64(message.rowsScanned);
        /* uint64 blocksScanned = 3; */
        if (message.blocksScanned !== 0)
            writer.tag(3, WireType.Varint).uint64(message.blocksScanned);
        /* uint64 rowsReturn = 4; */
        if (message.rowsReturn !== 0)
            writer.tag(4, WireType.Varint).uint64(message.rowsReturn);
        /* uint32 error = 5; */
        if (message.error !== 0)
            writer.tag(5, WireType.Varint).uint32(message.error);
        /* string message = 6; */
        if (message.message !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message nebula.service.Statistics
 */
export const Statistics = new Statistics$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryResponse$Type extends MessageType<QueryResponse> {
    constructor() {
        super("nebula.service.QueryResponse", [
            { no: 1, name: "stats", kind: "message", T: () => Statistics },
            { no: 2, name: "type", kind: "enum", T: () => ["nebula.service.DataType", DataType] },
            { no: 3, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<QueryResponse>): QueryResponse {
        const message = { type: 0, data: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryResponse): QueryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* nebula.service.Statistics stats */ 1:
                    message.stats = Statistics.internalBinaryRead(reader, reader.uint32(), options, message.stats);
                    break;
                case /* nebula.service.DataType type */ 2:
                    message.type = reader.int32();
                    break;
                case /* bytes data */ 3:
                    message.data = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* nebula.service.Statistics stats = 1; */
        if (message.stats)
            Statistics.internalBinaryWrite(message.stats, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* nebula.service.DataType type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).int32(message.type);
        /* bytes data = 3; */
        if (message.data.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message nebula.service.QueryResponse
 */
export const QueryResponse = new QueryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LoadRequest$Type extends MessageType<LoadRequest> {
    constructor() {
        super("nebula.service.LoadRequest", [
            { no: 1, name: "type", kind: "enum", T: () => ["nebula.service.LoadType", LoadType] },
            { no: 2, name: "table", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "json", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "ttl", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<LoadRequest>): LoadRequest {
        const message = { type: 0, table: "", json: "", ttl: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LoadRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LoadRequest): LoadRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* nebula.service.LoadType type */ 1:
                    message.type = reader.int32();
                    break;
                case /* string table */ 2:
                    message.table = reader.string();
                    break;
                case /* string json */ 3:
                    message.json = reader.string();
                    break;
                case /* uint32 ttl */ 4:
                    message.ttl = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LoadRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* nebula.service.LoadType type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* string table = 2; */
        if (message.table !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.table);
        /* string json = 3; */
        if (message.json !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.json);
        /* uint32 ttl = 4; */
        if (message.ttl !== 0)
            writer.tag(4, WireType.Varint).uint32(message.ttl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message nebula.service.LoadRequest
 */
export const LoadRequest = new LoadRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LoadResponse$Type extends MessageType<LoadResponse> {
    constructor() {
        super("nebula.service.LoadResponse", [
            { no: 1, name: "error", kind: "enum", T: () => ["nebula.service.LoadError", LoadError] },
            { no: 2, name: "loadTimeMs", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "table", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<LoadResponse>): LoadResponse {
        const message = { error: 0, loadTimeMs: 0, table: "", message: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LoadResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LoadResponse): LoadResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* nebula.service.LoadError error */ 1:
                    message.error = reader.int32();
                    break;
                case /* uint32 loadTimeMs */ 2:
                    message.loadTimeMs = reader.uint32();
                    break;
                case /* string table */ 3:
                    message.table = reader.string();
                    break;
                case /* string message */ 4:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LoadResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* nebula.service.LoadError error = 1; */
        if (message.error !== 0)
            writer.tag(1, WireType.Varint).int32(message.error);
        /* uint32 loadTimeMs = 2; */
        if (message.loadTimeMs !== 0)
            writer.tag(2, WireType.Varint).uint32(message.loadTimeMs);
        /* string table = 3; */
        if (message.table !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.table);
        /* string message = 4; */
        if (message.message !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message nebula.service.LoadResponse
 */
export const LoadResponse = new LoadResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServiceInfo$Type extends MessageType<ServiceInfo> {
    constructor() {
        super("nebula.service.ServiceInfo", [
            { no: 1, name: "ipv4", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "port", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "host", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "tier", kind: "enum", T: () => ["nebula.service.ServiceTier", ServiceTier] }
        ]);
    }
    create(value?: PartialMessage<ServiceInfo>): ServiceInfo {
        const message = { ipv4: "", port: 0, host: "", tier: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ServiceInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ServiceInfo): ServiceInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ipv4 */ 1:
                    message.ipv4 = reader.string();
                    break;
                case /* uint32 port */ 2:
                    message.port = reader.uint32();
                    break;
                case /* string host */ 3:
                    message.host = reader.string();
                    break;
                case /* nebula.service.ServiceTier tier */ 4:
                    message.tier = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ServiceInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ipv4 = 1; */
        if (message.ipv4 !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.ipv4);
        /* uint32 port = 2; */
        if (message.port !== 0)
            writer.tag(2, WireType.Varint).uint32(message.port);
        /* string host = 3; */
        if (message.host !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.host);
        /* nebula.service.ServiceTier tier = 4; */
        if (message.tier !== 0)
            writer.tag(4, WireType.Varint).int32(message.tier);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message nebula.service.ServiceInfo
 */
export const ServiceInfo = new ServiceInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PingResponse$Type extends MessageType<PingResponse> {
    constructor() {
        super("nebula.service.PingResponse", []);
    }
    create(value?: PartialMessage<PingResponse>): PingResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PingResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PingResponse): PingResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: PingResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message nebula.service.PingResponse
 */
export const PingResponse = new PingResponse$Type();
/**
 * @generated ServiceType for protobuf service nebula.service.V1
 */
export const V1 = new ServiceType("nebula.service.V1", [
    { name: "Echo", options: {}, I: EchoRequest, O: EchoResponse },
    { name: "Tables", options: {}, I: ListTables, O: TableList },
    { name: "State", options: {}, I: TableStateRequest, O: TableStateResponse },
    { name: "Query", options: {}, I: QueryRequest, O: QueryResponse },
    { name: "Load", options: {}, I: LoadRequest, O: LoadResponse },
    { name: "Nuclear", options: {}, I: EchoRequest, O: EchoResponse },
    { name: "Url", options: {}, I: UrlData, O: UrlData },
    { name: "Ping", options: {}, I: ServiceInfo, O: PingResponse }
]);
